\newpage
\section{Implementierung}

Wie in Abschnitt XX bereits erwähnt ist die Applikation dem Design-Pattern Model-View-Controller nachempfunden. Im Folgenden wird nun die konkrete Implementierung beschrieben und die Architektur mittels Codebeispielen konkretisiert.
\\
Der allgemeine Ablauf der Anwendung sieht lediglich einen Aufruf der HTML-Seite index.html vor. In diese wird mittels Javascript der jeweilige Inhalt (eine View) geladen und mit Daten und Funktionen (Controller) und versorgt.
\\
\includegraphics[width=1\textwidth]{ref/images/index.png} \\ 
App.js ist eine Javascript-Datei, die die Zuordnung der Views zu ihrem jeweiligen Controller durchführt. An dieser Stelle ist pro View ein Status (state) hinterlegt, der die folgenden Informationen definiert (Name des Status, URL (innerhalb der App), View-Bezeichnung (URL der View, Controllername)). Die Informationen über die aktuell gewählte View gibt app.js an index.html zurück, welche sie nach außen dem Nutzer darstellt.
\\
App.js wird bei jedem Start der Applikation zuerst geladen. Dabei findet auch immer eine Prüfung der aktuellen Internetverbindung statt. Internet wird für die Darstellung des Kartenmaterials benötigt. Die Konsequenz einer fehlenden Internetverbindung ist demnach ein Abbruch der Applikation.
\\
Standardmäßig wird bei korrektem Startverhalten die play-View geladen. Das ist eine ebenfalls in app.js definierte Defaulteinstellung.
\\
Alle folgenden Statusbeschreibungen trennen View, Controller und Modell schematisch voneinander, wobei der Begriff Modell durch den Cordova-spezifischen Begriff Service ersetzt wird.
\\
Die App besitzt einen getabbten Aufbau, das heißt es existiert eine Kopfzeile, die dem Nutzer vier verschiedene Tabs anbietet: Spielen, Highscores, Account und Credits. 
\\
Die in index.html angezeigten Tabs sind ein Spezialstatus, der in app.js als abstrakt gekennzeichnet ist und ständig im Hintergrund aktiv ist. Alle folgenden Tabs bauen auf diesem abstrakten Status auf.
\\
\includegraphics[width=1\textwidth]{ref/images/tabs.png} \\ 

Jeder der Tabs wird im Folgenden näher beschrieben werden.

\subsection{Spielen-Tab}
Der Spielen-Tab bietet dem Nutzer die Möglichkeit ein Spiel zu starten. Er gibt dafür einen Namen und einen Spielradius an. Unter dieser Kombination wird er später seinen Highscore dieses Spiels finden können. Die View, die dahinter steht ist die Play-View, welche prinzipiell im Spielen-Tab als Startseite der Applikation angezeigt wird. 
\subsubsection{Play-View}
%
%Beschreibung der HTML-Seite
%
Die Play-View hat ein Textfeld, dass den Spielernamen übernehmen kann und eine Selectbox, die den Radius auf zwei bis fünf Kilometern beschränkt. Bei fehlender Eingabe wird auf drei Kilometer als Defaultwert gesetzt. Außerdem bietet die View einen Button, der das Spiel startet. 
%
%Ablaufplan
%
\\ \includegraphics[width=1\textwidth]{ref/images/02-play-tab.png} \\
%
% Beschreibung des Controllers und der Services
%
Der Play-View wurde über app.js der Controller 'PlayCtrl' zugewiesen, der wiederum Zugang zum Service 'Player' besitzt. Der 'Player'-Service kapselt alle Funktionen, die mit den Nutzerdaten im Zusammenhang stehen.
\\
% Verwendungszweck
\\
Schon während der Eingabe der benötigten Informationen (Name und Radius) wird ein JS-Objekt 'player' generiert, das diese Daten enthält. Mit Druck auf den Button 'Los gehts' an die Funktion 'savePlayer' des Controllers übergeben wird. 
\\
Der Controller leitet bei Aufruf dieser Funktion die Objektdaten Name und Radius an den dazugehörigen Service 'Player', der zuerst auf gültige Befüllung des Spielernamen prüft und bei Befüllung diesen speichert. Der genutzte Speicher ist der sessionStorage des Geräts, der für die Dauer der Session die Daten des Spielers als Objekt mit den folgenden Eigenschaften speichert: 
\begin{enumerate}
\item Spielername und Radius: beides über Nutzer eingegeben und über Controller an Service zur Speicherung übergeben
\item Score: Punktestand des Spielers
\item StartpositionLat: Breitengrad der Startposition
\item startpositionLong: Längengrad der Startposition
\item lastDist: letzte Distanz zum Ziel für Verlaufsvergleich
\item dbID: ID des Spielers im Spielerarray des Sessionstorage
\item lastUpdate: Zeitpunkt der letzten Änderung
\end{enumerate}
Die noch nicht existierenden Werte werden mit Defaultwerten gefüllt.
\\
Wenn der Spielername nicht angegeben wurde erhält der Nutzer eine Aufforderung und das Spielerobjekt wird nicht weitergeleitet/gespeichert. Bei erfolgreichem Speichern hingegen erfolgt über den Service eine Weiterleitung in den Status 'tab-game'.

\subsubsection{Game-View}
%
%Beschreibung der HTML-Seite
%
Die Game-View liegt ebenfalls im Tab 'Spielen' und ist für die aktuelle Standortbestimmung - also die Bestimmung des Startpunkts des Nutzers zuständig.
\\
Sie besitzt anfänglich lediglich einen Button, der die Positionsbestimmung anstößt. Bei fehlerfreier Ermittlung wird dem Nutzer eine Open Street Map mit seiner Position und dem eingezeichneten Radius angezeigt, sodass er einen Überblick über sein 'Spielfeld' bekommt. Außerdem wird ein weiterleitender Button eingeblendet, über den der Spieler die Spielmöglichkeiten in seinem berechneten Umfeld angeboten erhält.
Bei Fehlern bei der Positionsbestimmung erhält der Nutzer anstelle der Karte und des Button schriftliche Rückmeldung über die Art seines Fehlers.
%
%Ablaufplan
%
\\ \includegraphics[width=1\textwidth]{ref/images/03-game-tab.png} \\
%
% Beschreibung des Controllers und der Services
%
Die Game-View ist an den Controller 'GameCtrl' gebunden, welcher auf drei verschiedene Services zugreifen kann: Player, Location und Task.
\\
Der Player Service kümmert sich, wie erwähnt um die Nutzerdaten. Der Location Service wurde entwickelt, um die Positionsbestimmung und die Behandlung der Koodinatendaten zu kapseln. Der Task Service hingegen gewährleistet die Generierung, Verfolgung und Speicherung der Aufgaben (Tasks) der ganzen Applikation.
\\
% Verwendungszweck
\\
Die Nutzung der Applikation sieht eine Bestimmung der Startposition eines Spielers vor Erstellung der Aufgaben vor. Der Spieler erhält auf der Game-View eine kurze Übersicht seiner bisher gemachten Angaben (Spielername und Radius). Dieser werden vom Controller vor dem endgültigen Laden der View beim Service Player angefragt (getData()). Der Player-Service muss dafür auf den sessionStorage des Geräts zugreifen und das 'player'-Objekt auslesen.
\\
\\
Nach dem Laden der View kann der Nutzer dann über den Button 'Startposition finden' seine aktuelle Position bestimmen lassen. Mit Klick auf den Button wird über den Controller, bzw. über seine Funktion 'positionMe', die Funktion des Location Service aufgerufen werden ('getPosition'). Diese Funktion ist nicht nur für die eigenliche Bestimmung der Koordinaten, sondern auch für die Speicherung jener Daten verantwortlich.
\\
Dafür werden ihr die Spielerdaten über das Objekt 'player' übergeben und die Funktion zur Speicherung der Daten als Javascript-Callback Funktion im Falle einer korrekten Ermittlung.
\\
Der Befehl 'navigator.geolocation.getCurrentPosition()' ist der Weg, um auf die Geolokationsfunktionen von Cordova, bzw. des Geräts zuzugreifen. Nach diesem Aufruf werden die Felder der Game-View (Infotext, mapDiv und playTasks) entsprechend gefüllt und bei erfolgreicher Durchführung die Startpositionsdaten des Spielers (vgl. Callbackfunktion) im sessionStorage aktualisiert und der Spieler in das Spielerarray des Localstorage integriert. Der Localstorage des Geräts enthält im Vergleich zum Sessionstorage zu jeder Zeit seine Daten und wird nicht automatisch gelöscht. Das Array enthält also alle Spieler, die dann später auch im Highscore aufgelistet werden können.
\\
Wenn es bei der Positionierung zu Problemen kommt, erhält der Nutzer Rückmeldung nachdem die Timeout-Zeit von 30 Sekunden abgelaufen ist.
\\
Bei erfolgreicher Positionierung werden die Koordinaten über das mapDiv, einem Bereich der Game-View, in einer Open Street Map dargestellt (vgl. Kapitel XXX). Außerdem wird in diesem Fall der Button 'Aufgaben spielen' eingeblendet.
\\
Wird dieser Button 'Aufgaben spielen' daraufhin gedrückt, startet der Controller die Erstellung der Aufgaben für den Spieler.
\\
In dieser prototypischen Implementierung ist nur eine fixe Anzahl von Aufgaben implementiert, die von den Entwicklern frei bestimmt wurden und in einem Array gespeichert sind.
\\
Jede Aufgabe in dieser Sammlung hat folgende Informationen:
\begin{enumerate}
\item id: Identifikationsnummer der Aufgabe
\item Name: schriftliche Bezeichnung der Aufgabe
\item taskPosLat: Aufgaben-Längengrad
\item taskPosLong: Aufgaben-Breitengrad
\end{enumerate}

Folgende beispielhaften Aufgaben sind im Prototypen implementiert.
\begin{lstlisting}
        var taskCollection = [
            {
                id: 0,
                name: "Mannheim Hbf",
                taskPosLat: 49.479904895467314,
                taskPosLong: 8.470357013095054
            },
            {
                id: 1,
                name: "Mannheim Universitaet",
                taskPosLat: 49.48373966279436,
                taskPosLong: 8.46222996711731
            },
            {
                id: 2,
                name: "Mannheim Wasserturm",
                taskPosLat: 49.48336089947494,
                taskPosLong: 8.477369150878872
            },
            {
                id: 3,
                name: "Mannheim Neckar",
                taskPosLat: 49.490776620594524,
                taskPosLong: 8.482561907531704
            },
            {
                id: 4,
                name: "Mannheim Rhein",
                taskPosLat: 49.494403359335486,
                taskPosLong: 8.456469378234829
            },{
            ...
            }]
\end{lstlisting}
Der Controller ruft die Erstellung der Aufgaben für den Spieler über die Funktion 'newTasks' des Service Task auf.
\\
Der Service berechnet daraufhin für jede Aufgabe in seiner Sammlung die Entfernung, die der Spieler zu der jeweiligen Position hätte und speichert sie in ein Spieler-Aufgabenarray, wenn die Distanz kleiner oder gleich dem vom Spieler gewählten Radius ist.
\\
Die Berechnung der Distanz erfolgt über die Funktion 'getDistance', welche im Folgenden aufgeführt ist.
\begin{lstlisting}
        function getDistance(lat1, lon1, lat2, lon2) {
            var R = 6371; // Radius der Erde in Kilometern
            var dLat = deg2rad(lat2 - lat1);
            var dLon = deg2rad(lon2 - lon1);
            var a =
                    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2)
                ;
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            var d = R * c;
            return d;
        }
        function deg2rad(deg) {
            return deg * (Math.PI / 180)
        }
\end{lstlisting}
Diese Funktion gibt die Distanz zwischen zwei Punkten in Kilometern zurück.
\\
Jede Aufgabe, die im Spielerradius liegt, wird mit folgenden Informationen im Spieler-Aufgabenarray hinterlegt.
\begin{itemize}
\item id: Aufgabenidentifikationsnummer
\item name: Name der Aufgabe
\item distance: Entfernung von Startposition mit vier Nachkommastellen
\item score: Punktestand des Spielers
\item taskPosLat: Aufgaben-Breitengrad
\item taskPosLong: Aufgaben-Längengrad
\item stateFinished: Statusanzeige, ob Aufgabe erledigt wurde
\item stateIgnore: Statusanzeige, ob Aufgabe ignoriert werden soll (im Prototypen noch ungenutzt, daher standardmäßig auf false gesetzt)
\end{itemize}
Am Ende wird das Spieler-Aufgabenarray ebenfalls im Sessionstorage des Geräts gespeichert. Die App ist so gestaltet, dass eine Session einem Spiel mit einer Aufgabenliste entspricht, bei der Punkte gewonnen werden können. Ein Neustart der App bedeutet eine neue Aufgabenliste für den Spieler.
\\
Nach Erstellung der Aufgabenliste für den Nutzer wird dieser auf die Tasks-View weitergeleitet, die diese Liste anzeigt.
\subsubsection{Tasks-View}
%
%Beschreibung der HTML-Seite
%
Die Tasks-View besteht selbst lediglich aus einer Liste von Buttons und einer Punkteanzeige für den Spieler.
%
%Ablaufplan
%
\\ \includegraphics[width=1\textwidth]{ref/images/04-tasks-tab.png} \\
%
% Beschreibung des Controllers und der Services
%
Die Tasks-View wurde über app.js der Controller 'TasksCtrl' zugewiesen, der wiederum Zugang zum Service 'Player' und 'Task' besitzt. Der 'Player'-Service kapselt alle Funktionen, die mit den Nutzerdaten im Zusammenhang stehen und 'Task' hat die volle Übersicht über die Aufgaben des Spielers.
\\
% Verwendungszweck
\\
Dem Nutzer werden seine aktuell erreichen Punkte angezeigt, die über den Player Service vom Controller angefragt werden. Genauso bereitet der Controller die Liste der Aufgaben, die er vom Task Service erhält für den Nutzer auf indem er eine Liste von Elementen (Button) anzeigt, die zu der jeweiligen Aufgaben führen sollen. Diese Ermittlungen erfolgen vor dem Laden der View.
\\
Ebenfalls vor dem Anzeigen der HTML-Seite prüft der Controller noch, ob bereits die Position des Geräts geprüft wird. Es könnte ja auch sein, dass der Nutzer die Aufgabe, die er gerade spielt abbricht und auf die Seite mit der übersichtlichen Aufgabenliste zurückkehrt. In diesem Fall wird die sogenannte Watch-ID, die mit der Positionsüberwachung vergeben und im Sessionstorage gespeichert wurde, gelöscht (clearWatchID(id)).
\\
Der Nutzer hat dann nach dem Laden der View die Möglichkeit eine Aufgabe auszuwählen, indem er auf einen der Buttons drückt. Damit stößt er im Controller die Funktion 'play' an, der er (über die Auswahl des Button) die entsprechende Aufgaben-ID übergibt. Der Controller startet diese Aufgabe über den Task Service, bzw. seine Funktion 'setActualTask(taskID)' während der Nutzer an die Task-View weitergeleitet wird.
\subsubsection{Task-View}
%
%Beschreibung der HTML-Seite
%
Die Task-View ist die Übersichtsseite für eine Aufgabe. Dem Spieler wird die Startentfernung, sein aktueller Punktestand für diese eine Aufgabe genannt. Außerdem bekommt er, wie bei einer Wünschelrute einen Hinweis, ob er sich vom Ziel entfernt oder ob er sich ihm nähert. Dieser Hinweis erscheint nur, wenn er sich auch bewegt, das heißt, wenn sich der Abstand zum Ziel ändert. Ab diesem Moment findet die Positionierung durch die Applikation durchgängig statt.
%
%Ablaufplan
%
\\ \includegraphics[width=1\textwidth]{ref/images/05-task-tab.png} \\
%
% Beschreibung des Controllers und der Services
%
Der Task-View wurde über app.js der Controller 'TaskCtrl' zugeordnet. Dieser sorgt dafür, dass die Informationen über die Aufgabe angezeigt werden. Dafür hat er Zugriff auf den Task Service, bei dem er über die Task-ID alles über die Aufgabe erfahren kann. Die akutelle Task-ID wurde zuvor vom Task Service im Sessionstorage abgelegt und kann jederzeit eingesehen ('getActualTask'-Funktion) und bei Bedarf auch wieder gelöscht werden.
\\
Die Ermittlung der aktuellen Aufgabe und ihrer Informationen findet ebenfalls wieder vor dem Laden der View statt. Genauso muss vor dem Anzeigen auch die letzte gemessene Distanz zurückgesetzt werden. Dafür ist der Player Service zuständig, da es sich bei der Distanz um einen spielerbezogenen Wert handelt. Dafür ruft der Controller die Funktion 'resetLastDist' auf, über die der Player Service diese Angabe des Spielers auf die Startdistanz der Aufgabe initialisiert.
\\
Wenn der Controller dann feststellt, dass die Aufgabe noch nicht zu Ende gespielt wurde (Prüfung des stateFinished), kann das Spiel beginnen und der Location Service startet die Funktion 'watch'. Wenn das Spiel bereits erfolgreich durchlaufen wurde, wird dies dem Nutzer über eine entsprechende Meldung (finished) mitgeteilt, ansonsten bleibt die Variable ohne Textinhalt.
\\
Die 'watch'-Funktion des Location Service nutzt wie auch bei der Startpositionsbestimmung den 'navigator.geolocation'. Dieser besitzt eine Funktion 'watchPosition', die eine ID zurückgibt (im Sessionstorage hinterlegt) und solange die Position bei Änderung ermittelt bis die ID gelöscht wird (clearWatch(ID)).
\\
Der Ablauf bei erfolgreicher Positionsbestimmung besagt, dass dem Nutzer jeweils seine neue Distanz, die Tendenz über eine farbliche Daumengeste, sowie die neue Punktzahl entsprechend Annäherung/Entfernung angezeigt werden (distTitel, distance, color, Verlauf, scores). Bei Annäherung bekommt der Spieler einen Punkt dazu bei Entfernung einen Punkt abgezogen.
\\
Wenn die Distanz kleiner als zehn Meter beträgt, gilt die Aufgabe als ab<solviert. Dafür bekommt der Spieler zehn Punkte und die Watch-ID wird gelöscht.
\\
Außerdem werden in diesem Fall die Aufgabe, bzw. der Score für diese Aufgabe und die Gesamtpunkte für den Spieler aktualisiert und gespeichert.
\\
Bei Fehlern bei der Positionsbestimmung erfolgt eine Fehlermeldung nachdem die Timeout-Zeit von 60 Sekunden abgelaufen ist. Die Zeit ist bei der 'watch'-Funktion doppelt so hoch eingestellt, wie bei der Erstbestimmung. Die Erstbestimmung muss für den Nutzer ersichtlich schnell geschehen. Wenn er erst einmal eine Aufgabe verfolgt, kann es schneller mal passieren, dass das Gerät die Position verliert. Sie sollte jedoch sehr robust gegen 'GPS-Löcher' sein und daher wurde die Zeit in dem Fall sehr hoch gewählt, sodass es zu keinem Aufgabenabbruch kommt. In diesem Fall wird natürlich auch die Watch-ID gelöscht.
\subsection{Highscores-Tab}
Der Highscores-Tab besteht im Gegensatz zum Spielen-Tab lediglich auch einer View - der Highscores-View.
\subsubsection{Highscores-View}
%
%Beschreibung der HTML-Seite
%
Diese View ist die Übersichtsseite für alle gespeicherten Highscores.
%
%Ablaufplan
%
\\ \includegraphics[width=1\textwidth]{ref/images/06-highscores-tab.png} \\
%
% Beschreibung des Controllers und der Services
%
Der Highscores-View wurde über app.js der Controller 'HighscoresCtrl' zugewiesen, der Zugriff auf den Player Service hat.
\\
Der Controller ist lediglich für die Anzeige von Highscore-Daten zuständig und besitzt daher keine Funktionen, die über die View aufgerufen werden können. Allerdings lädt er vor der Anzeige der View die Highscore-Daten, die der Player Service über die Funktion 'getHighscores' anbietet.
\\
Der Player Service lädt dafür das Spielerarray, welches im Localstorage des Geräts hinterlegt wurde und sortiert es absteigend. Die Highscore-View zeigt dann lediglich die Spieler des Arrays in dieser Reihenfolge an und gibt die Hintergrundinformationen Spielername, Radius, Zeitpunkt der letzten Änderung und Punktzahl mit an.
\subsection{Account-Tab}
Der Account-Tab besteht ebenfalls aus einer einzigen View - der Account-View.
\subsubsection{Account-View}
%
%Beschreibung der HTML-Seite
%
Die View ist für verschiedene Einstellungen gedacht, die der Spieler der Applikation geben können soll. Im Prototypen wurde an dieser Stelle der Reset-Button zum Zurücksetzen der Highscores implementiert.
%
%Ablaufplan
%
\\ \includegraphics[width=1\textwidth]{ref/images/07-account-tab.png} \\
%
% Beschreibung des Controllers und der Services
%
Der Account-View wurde über app.js der Controller 'AccountCtrl' zugewiesen, der Zugriff auf den Player Service hat.
\\
Mit Klick auf den Button 'Highscores löschen' werden über den Controller bzw. über den Player Service alle Daten aus dem lokalen und dem Sessionstorage gelöscht ('emptyHighscores'-Funktion). Im Anschluss daran wird der Nutzer auf die Startseite (Play-View) zurückgeleitet.
\subsection{Credits-Tab}
Der Credits-Tab besteht ebenfalls aus einer einzigen View - der Credits-View.
\subsubsection{Credits-View}
%
%Beschreibung der HTML-Seite
%
Diese View ist besonders. Ihr wurde zwar ein Controller ('CreditsCtrl') zugewiesen. Da die Danksagungsseite jedoch keinerlei Funktionalität benötigt und auch keine Daten vor dem Laden erhalten muss, kann man sie als einfache HTML-Seite betrachten, die textuellen Inhalt im Original wiedergibt. Es existiert demnach auch kein Ablaufplan.
\subsection{Umsetzung iBeacons}
Ziel der Umsetzung in dieser Arbeit ist, dass die definierten Zielpunkte der App mit jeweils einem iBeacon ausgestattet werden.Damit diese die Genauigkeit der Entfernung verbessern.
Hierfür muss die App Signale des iBeacons empfangen. Deshalb läuft während der gesamten Ortungsphase im Hintergrund ein iBeacon Scanner. Sobald dieser Scanner den gewünschten iBeacon entdeckt hat wird die Distanz zum Ziel durch den iBeacon bestimmt und nicht per GPS, dadurch wird eine höhere Genauigkeit im Zielgebiet erreicht.

Um dies zu implementieren, muss das Zielpunkt Objekt angepasst werden. Standortobjekte benötigen neben Namen und Positionen noch eine iBeacon ID sowie Major und Minor Werte.

Mit den neuen Werten sind alle Vorraussetzungen geschaffen um einen iBeacon Scanner zu implementieren. Hierfür wird das Plug-In "Cordova / Phonegap iBeacon plugin" von Peter Metz verwendet. Es ist open Source und kann von Git Hub heruntergeladen werden.

Das Plug-In enthält Schnittstellen und Funktionen zum finden von iBeacons. Hierbei werden zwei unterschiedliche Funktionalitäten geboten.


1. Monitoring von iBeacons
Beim Monitoring wird ständig überprüft ob das Smartphone welches das Plug-In nutzt in einen Bereich eintritt, indem ein iBeacon Signale sendet. Ebenfalls wird überprüft ob das Smartphone den Bereich verlässt. Diese Funktion wird in dieser Arbeit genutzt um dem User anzuzeigen, dass bei Eintritt in eine iBeacon Zone nicht mehr GPS genutzt wird, sondern die Abstandsbestimmung mit Hilfe des iBeacons erfolgt.

2. Ranging von iBeacons
Während Monitoring nur den Aus- bzw. Einritt in eine Zone überprüft, ermittelt das iBeacon Ranging alle in der nähe befindlichen iBeacons und gibt eine ungefähre Distanz zu diesen an. Diese Funktionalität wird genutzt um die Distanz zum Zielort in der App darzustellen.\cite{MonitorRange}


Im folgenden wird die Umsetzung anhand von Quellcode Beispielen erläutert:

Installation
Damit das Plug-In genutzt werden kann, muss es erst über die Console des Betreibssystem installiert werden.

Hierfür navigiert man in der Console zum Hauptordner der App. Dort führt man den Befehl:

\begin{lstlisting}
cordova plugin add https://github.com/petermetz/cordova-plugin-ibeacon.git
\end{lstlisting} 


aus. Draufhin erfolgt die Automatische Installation im Ordner "plugin" der App und es kann auf die Schnittstellen zugegriffen werden.

Der allgemeine Ablauf besteht aus mehreren Schritten:
\begin{enumerate}
\item Schritt Anlegen eines Arrays mit iBeacon Informationen
\item Schritt Hauptfunktion mit for-Schleife aufrufen
\item Schritt Warten auf einen iBeacon in Reichweite
\item Schritt Gefundenes iBeacon-Objekt in Variable schreiben
\item Schritt Daten aus Objekt auslesen und anzeigen
\end{enumerate}



\underline{TODO: An dieser Stelle wird mit Code-Listings die Umsetzung dieser Schritte }\\
\underline{detailliert erläutert werden.}
